<!DOCTYPE html>
<html>
<head>
  <title>Lavaball</title>
  <style>
    body {
      margin: 0px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <script src="js/three.min.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    uniform vec2 resolution;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
    #define PI 3.1415926535898

    uniform float time;
    uniform vec2 resolution;
    uniform vec4 mouse;

    const int max_iterations = 64;
    const float step_scale = 0.9;
    const float eps = 0.005;

    float dSphere(vec3 p, vec3 center_pos, float radius) {
      return length(p - center_pos) - radius;
    }

    float dRoundBox(vec3 p, vec3 center_pos, vec3 box_sides_length, float roundness) {
      return length(max(abs(p - center_pos) - box_sides_length, 0.0)) - roundness;
    }

    float dSinusoidBumps(in vec3 p) {
      return sin(p.x * 16. + time * 0.57) * cos(p.y * 16. + time * 2.17) * sin(p.z * 16. - time * 1.31) +
        0.5 * sin(p.x * 32. + time * 0.07) * cos(p.y * 32. + time * 2.11) * sin(p.z * 32. - time * 1.23);
    }

    float scene(vec3 p) {
      vec3 pos_offset = vec3(mod(time / 4., 4.) - 2., 0., 1.);
      return min(
        dSphere(p, pos_offset + vec3(.2, .0, .0), .2 + 0.015 * dSinusoidBumps(p)),
        dRoundBox(p, pos_offset, vec3(0.1, 0.002, 0.002), 0.1) + 0.12 * dSinusoidBumps(p)
      );
    }

    vec3 getNormal(in vec3 p) {
      return normalize(vec3(
        scene(vec3(p.x + eps, p.y, p.z)) - scene(vec3(p.x - eps, p.y, p.z)),
        scene(vec3(p.x, p.y + eps, p.z)) - scene(vec3(p.x, p.y - eps, p.z)),
        scene(vec3(p.x, p.y, p.z + eps)) - scene(vec3(p.x, p.y, p.z - eps))
      ));
    }

    float rayMarching(vec3 origin, vec3 dir, float start, float end) {
      float dist_to_scene = 1e4;
      float ray_length = start;
      for (int i = 0; i < max_iterations; ++i) {
        dist_to_scene = scene(origin + dir * ray_length);
        if (dist_to_scene < eps || ray_length >= end) {
          break;
        }
        ray_length += dist_to_scene * step_scale;
      }
      if (dist_to_scene >= eps)
        ray_length = end;
      else
        ray_length += dist_to_scene;
      return ray_length;
    }

    void main(void) {
      float aspect_ratio = float(resolution.x) / float(resolution.y);
      float u = (gl_FragCoord.x * 2.0 / resolution.x - 1.0) * aspect_ratio;
      float v = (gl_FragCoord.y * 2.0 / resolution.y - 1.0);
      vec3 look_at = vec3(0., 0., 0.);
      vec3 cam_pos = vec3(0., 0., -1.);
      float FOV = 0.5;
      vec3 forward = normalize(look_at - cam_pos);
      vec3 right = normalize(vec3(forward.z, 0., -forward.x));
      vec3 up = normalize(cross(forward, right));
      vec3 ro = cam_pos;
      vec3 rd = normalize(forward + FOV * u * right + FOV * v * up);
      vec4 bg_color = vec4(.15, .0, .0, 1.0);
      const float clip_near = 0.0;
      const float clip_far = 4.0;
      float dist_to_scene = rayMarching(ro, rd, clip_near, clip_far);
      if (dist_to_scene >= clip_far) {
        gl_FragColor = bg_color;
        return;
      }
      vec3 surf_pos = ro + rd * dist_to_scene;
      vec3 surf_normal = getNormal(surf_pos);
      vec3 light_pos = vec3(1.5 * sin(time * 0.5), 0.75 + 0.25 * cos(time * 0.5), -1.0);
      vec3 light_dir = light_pos - dist_to_scene;
      vec3 light_color = vec3(1., 0.97, 0.92);
      float light_to_point_dist = length(light_dir);
      light_dir /= light_to_point_dist;
      float light_attenuation = min(1.0 / (0.25 * light_to_point_dist * light_to_point_dist), 1.0);
      vec3 light_reflection_dir = reflect(-light_dir, surf_normal);
      vec3 color = vec3(0.0);
      vec3 obj_color = vec3(sin(time * 0.5), cos(time * 0.5), 0.5);
      float obj_ambient = .1;
      float obj_specular_power = 360.0;
      float obj_diffuse = max(0.0, dot(surf_normal, light_dir));
      float obj_specular = max(0.0, dot(light_reflection_dir, normalize(cam_pos - surf_pos)));
      obj_specular = pow(obj_specular, obj_specular_power);
      color += (obj_color * (obj_diffuse * 0.8 + obj_ambient) + obj_specular * 0.5) * light_color * light_attenuation;
      gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
    }
  </script>

  <script>
    var container;
    var camera, scene, renderer;
    var uniforms;

    init();
    render();

    function init() {
      container = document.getElementById("container");

      camera = new THREE.Camera();
      camera.position.z = 1;

      scene = new THREE.Scene();

      uniforms = {
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() },
      };

      var material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: document.getElementById("vertexShader").textContent,
        fragmentShader: document.getElementById("fragmentShader").textContent,
      });

      scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

      renderer = new THREE.WebGLRenderer();
      container.appendChild(renderer.domElement);

      onWindowResize();
      window.addEventListener("resize", onWindowResize, false);
    }

    function onWindowResize(event) {
      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function render() {
      requestAnimationFrame(render);

      uniforms.time.value += 0.05;
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
